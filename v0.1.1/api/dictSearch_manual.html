<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>FSDict: DictSearch Manual - \n Approximate Search in Dictionaries in the Context of Historical Language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FSDict
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dictSearch_manual.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">DictSearch Manual - <br/>
 Approximate Search in Dictionaries in the Context of Historical Language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="DictSearch_summary"></a>
Summary</h1>
<p><a class="el" href="classfsdict_1_1DictSearch.html" title="fsdict::DictSearch is a combined interface for approximate dictionary lookup in the context of histor...">fsdict::DictSearch</a> is a combined interface for approximate dictionary lookup in the context of historical language. The scenario is that the users specify a variety of dictionaries of different types to perform exact or approximate dictionary lookups. These types include</p>
<ul>
<li>ordinary word lists, maybe with some frequency or other annotation</li>
<li>historical dictionaries with annotated information on spelling variation</li>
<li>"hypothetic" historical dictionaries defined by a modern word list and a set of rewrite rules describing spelling variation.</li>
</ul>
<h2><a class="anchor" id="DictSearch_summary_queries"></a>
What you query, what you get as</h2>
<p>DictSearch can be configured to process query words <code>w</code> which might contain historical spelling variants, or OCR errors, or both. As an answer, you receive a set of "interpretations" for <code>w</code>, containing exact and approximate matches from either of the dictionaries. Such an interpretation has the following components:</p>
<ul>
<li><code>w</code> your query word</li>
<li><code>w_correct</code> the suggested correct word as it was found in the dictionary</li>
<li><code>ocr_trace</code> a description of which OCR errors were involved when turning <code>w</code> into <code>w_suggest</code> </li>
<li><code>w_modern</code> the suggested modern equivalent word</li>
<li><code>hist_trace</code> a description of which spelling variant patterns led to <code>w_modern</code> be spelled as <code>w_correct</code> </li>
</ul>
<p>In the usual application this answer set is understood as set of correction candidates for a (probably garbled) token <code>w</code>. The task of ranking these candidates is explicitly out of the scope of <a class="el" href="classfsdict_1_1DictSearch.html" title="fsdict::DictSearch is a combined interface for approximate dictionary lookup in the context of histor...">fsdict::DictSearch</a>: To decide for a correction candidate, various other techniques for channel and language modelling have to be taken into account.</p>
<p>This module is under construction. Please do help to extend the 'Known Issues' section at the end of this page. Also, this manual is work in progress. For now it concentrates on practical issues for the usage of the module. Some more details about the algorithms that were used will be added.</p>
<h1><a class="anchor" id="example_io"></a>
Example: Input/Output</h1>
<p>Let's start with an example, showing what the module offers. We load a very small modern dictionary with the following words and attached frequency scores: </p>
<div class="fragment"><div class="line">(feile#42, teile#84, teilen#101, teller#3, verteilen#18)</div>
</div><!-- fragment --><p> We also configure <a class="el" href="classfsdict_1_1DictSearch.html" title="fsdict::DictSearch is a combined interface for approximate dictionary lookup in the context of histor...">fsdict::DictSearch</a> to load a small historical dictionary (no frequency scores attached): </p>
<div class="fragment"><div class="line">(theil, theile, theller, theyl, theyle)</div>
</div><!-- fragment --><p> The hypothetic dictionary shall contain all variants of words from the modern dictionary, using the following variant patterns: </p>
<div class="fragment"><div class="line"><a class="code" href="stats_8cxx.html#a4b9927b953b7f438a60c0a441fd97308">t</a>-&gt;th, ei-&gt;ey. u-&gt;v</div>
</div><!-- fragment --><p> Finally, let's allow approximate matching only for the modern dictionary, with distance threshold 2.</p>
<p>Here's what DictSearch returns for the query "theile": </p>
<div class="fragment"><div class="line">Query: theile</div>
<div class="line">Output:</div>
<div class="line">theile:theile+[],dist=0,baseWordScore=0(historic)</div>
<div class="line">theile:teile+[(t_th,0)],dist=0,baseWordScore=84(modern)</div>
<div class="line">teile:teile+[],dist=1,baseWordScore=84(modern)</div>
<div class="line">theil:theil+[],dist=1,baseWordScore=0(historic)</div>
<div class="line">theyle:theyle+[],dist=1,baseWordScore=0(historic)</div>
<div class="line">feile:feile+[],dist=2,baseWordScore=42(modern)</div>
<div class="line">teilen:teilen+[],dist=2,baseWordScore=101(modern)</div>
</div><!-- fragment --><p> The meaning of all components can be seen best when investigating the 2nd answer: </p>
<div class="fragment"><div class="line">theile:teile+[(t_th,0)],dist=0,baseWordScore=84(modern)</div>
</div><!-- fragment --><ul>
<li>
'theile' is the candidate string itself. </li>
<li>
It is derived from 'teile' using a variant pattern 't-&gt;th' on position 0. This tells us the word is taken from the hypothetic dictionary. </li>
<li>
The exact string was found in the dictionary, thus the levenshtein distance is 0. </li>
<li>
The baseword (on which the variant pattern was applied) comes from the modern dictionary and had a score '84' attached. </li>
</ul>
<h1><a class="anchor" id="installation"></a>
Compilation/ Installation</h1>
<p>Please read the INSTALL file in the project root directory. The make command will compile a whole lot of things you don't need, but never mind. The open source program 'cmake' produces Makefiles for Linux and vcproj-files for MS Visual C++. On Windows, The project compiles, but with lots of warnings. At the moment, there's a major bug with Visual Studio 2008 connected to utf8 input. The problem does not exist with Visual Studio 2005.</p>
<h1><a class="anchor" id="fbdic"></a>
Dictionary Format: fbdic</h1>
<p>To use a dictionary with <a class="el" href="classfsdict_1_1DictSearch.html" title="fsdict::DictSearch is a combined interface for approximate dictionary lookup in the context of histor...">fsdict::DictSearch</a>, it has to be compiled into a finite-state automaton. <a class="el" href="classfsdict_1_1FBDic.html" title="Class FBDic (&quot;Foward-Backward-Dictionary&quot;) covers a dictionary and its reversed variant in one object...">fsdict::FBDic</a> is responsible for that. Please read in the <a class="el" href="fbDic_manual.html">FBDic Manual</a> how to get FBDic automata.</p>
<p>There are multiple ways to connect a dictionary to DictSearch:</p>
<ul>
<li>create binary files of the automata in an offline step using the tool compileFBDic (recommended for large dictionaries)<ul>
<li>and then simply pass on the filename to the DictSearch configuration</li>
<li>or load the file into a <a class="el" href="classfsdict_1_1FBDic.html" title="Class FBDic (&quot;Foward-Backward-Dictionary&quot;) covers a dictionary and its reversed variant in one object...">fsdict::FBDic</a> object and pass a reference of it to the DictSearch configuration</li>
</ul>
</li>
<li>To create the automata at runtime using <a class="el" href="classfsdict_1_1FBDic.html#a8d829ded20d834c9ebdd832543c34a97" title="compiles an FBDic from a .lex file. ">fsdict::FBDic::compileDic()</a></li>
</ul>
<h2><a class="anchor" id="fbdic_size"></a>
On the size of fbdics</h2>
<p>Unfortunately the resulting data structure is pretty large ( less than 62MB for a German dictionary of 2.9 million words) - that's because the approximate matching algorithm actually needs two variants of the automaton simultaneously in the memory. A slower variant of the search algorithm gets along with dictionaries of half the size.</p>
<h1><a class="anchor" id="configuration"></a>
Configuration</h1>
<p>The parameters that affect the candidate set are obvious: For the modern and for the historical dictionary, the result depends on the choice of the dictionaries themselves, and the upper bound of edit operations that are allowed for approximate search. In practice it makes sense to allow more edit operations for longer words - so the distance bound can be set in relation to the length of the query word. For the hypothetical dictionary, additional parameters are the set of orthographical variants and an upper bound for the number of applied variant patterns.</p>
<p>For configuration of the lookup in modern and historical dictionaries, DictSearch provides configuration objects via the following two methods: </p>
<ul>
<li>
fsdict::DictSearch::ConfigLookup&amp; fsdict::DictSearch::getConfigModern() </li>
<li>
fsdict::DictSearch::ConfigLookup&amp; fsdict::DictSearch::getConfigHistoric() </li>
</ul>
<p>Please consult the class reference of fsdict::DictSearch::ConfigLookup or the demo program below for details on how to set the above mentioned parameters.</p>
<h2><a class="anchor" id="hypothetic_configuration"></a>
Initialising and configuring the hypothetic dictionary</h2>
<p>The hypothetic dictionary uses a slightly extended object for configuration:</p>
<ul>
<li>fsdict::DictSearch::ConfigHypothetic&amp; fsdict::DictSearch::getConfigHypothetic()</li>
</ul>
<p>Furthermore the hypothetic dictionary must be initialised separately, using the method <a class="el" href="classfsdict_1_1DictSearch.html#a10d295ac746d3d9c23f97f90c24aae13" title="initialise the hypothetic dictionary. ">fsdict::DictSearch::initHypothetic( char const* patternFile )</a>. This method will activate the hypothetic dictionary, and its configuration can be changed as explained above.</p>
<p>Here is an example <code>patternFile</code>, the first line specifies that 't' might be spelled 'th' in historic documents. Use a colon ':' as delimiter. </p>
<div class="fragment"><div class="line"><a class="code" href="stats_8cxx.html#a4b9927b953b7f438a60c0a441fd97308">t</a>:th</div>
<div class="line">ei:ey</div>
<div class="line">u:v</div>
</div><!-- fragment --><p>This code-snippet shows a very simple way to initialise and configure a DictSearch. A more detailed example can be found at the bottom of this page. </p>
<div class="fragment"><div class="line"><span class="comment">// create a DictSearch-object</span></div>
<div class="line"><a class="code" href="classfsdict_1_1DictSearch.html" title="fsdict::DictSearch is a combined interface for approximate dictionary lookup in the context of histor...">fsdict::DictSearch</a> dictSearch;</div>
<div class="line"><span class="comment">// set a modern dictionary</span></div>
<div class="line">dictSearch.getConfigModern().setDict( <span class="stringliteral">&quot;path-to/some/modern.fbdic&quot;</span> );</div>
<div class="line"><span class="comment">// configure approx. search on modern dict. with distance bound 2</span></div>
<div class="line">dictSearch.getConfigModern().setDLev( 2 );</div>
<div class="line"></div>
<div class="line"><span class="comment">// set a historical dictionary</span></div>
<div class="line">dictSearch.getConfigHistoric().setDict( <span class="stringliteral">&quot;path-to/some/historical.fbdic&quot;</span> );</div>
<div class="line"><span class="comment">// configure approx. search on modern dict. to choose default distance bounds according to the word length</span></div>
<div class="line">dictSearch.getConfigHistoric().setDLevWordlengths();</div>
<div class="line"><span class="comment">// initialise the hypothetic dict. with a file of patterns</span></div>
<div class="line">dictSearch.<a class="code" href="classfsdict_1_1DictSearch.html#a10d295ac746d3d9c23f97f90c24aae13" title="initialise the hypothetic dictionary. ">initHypothetic</a>( <span class="stringliteral">&quot;path-to/some/patterns.txt&quot;</span> );</div>
</div><!-- fragment --><h1><a class="anchor" id="lookup"></a>
Lookup</h1>
<p>Different dictionaries, orthographic variants, approximate lookup: The answer to a DictSearch-query is more complex than it is for conventional fuzzy dictionary lookup. We hope we have found a way to keep things simple if the user is not interested in the details, and yet to keep things clear even if maybe the left side of the 3rd variant pattern of the 16th candidate is of special interest.</p>
<p>The method fsdict::DictSearch::query( std::wstring const&amp; word, fsdict::DictSearch::CandidateSet* candSet ) works with an input and an output argument.</p>
<ul>
<li><a class="el" href="classfsdict_1_1DictSearch_1_1Interpretation.html" title="This is a specialisation of fsdict::Interpretation, tailored to store additional information added by...">fsdict::DictSearch::Interpretation</a>, an extension of class <a class="el" href="classfsdict_1_1Interpretation.html" title="This class is something like a container class to store one interpretation of some string as the spel...">fsdict::Interpretation</a> - holds one candidate.</li>
<li><a class="el" href="classfsdict_1_1DictSearch_1_1CandidateSet.html" title="CandidateSet is a simple container to collect candidates/interpretations from either a Vaam or a fsdi...">fsdict::DictSearch::CandidateSet</a> is a container that holds a set of such interpretations. It is comparable to (in fact, implemented as) a std::vector&lt; fsdict::DictSearch::Interpretation &gt;, providing the standard access methods like begin(), end(), at() (see the class reference).</li>
</ul>
<p>This code-snippet shows a very simple way to query DictSearch. A more detailed example can be found at the bottom of this page. </p>
<div class="fragment"><div class="line">std::wstring query;</div>
<div class="line"><a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html" title="CandidateSet is a simple container to collect candidates/interpretations from either a Vaam or a fsdi...">fsdict::DictSearch::CandidateSet</a> candSet;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span>( std::getline( std::wcin, query ).good() ) {</div>
<div class="line">   candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a3f518bbf1e256610c61d4cd94cf73d80" title="method defined as usual for containers, e.g. ">clear</a>(); <span class="comment">// empty the CandidateSet</span></div>
<div class="line">   dictSearch.<a class="code" href="classfsdict_1_1DictSearch.html#adf7f634c5c410ac90223248f6f5bec2d">query</a>( query, &amp;candSet ); <span class="comment">// execute lookup</span></div>
<div class="line">   std::sort( candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a3d6bab588225734bd05b6f4e1bc51782" title="method defined as usual for containers, e.g. ">begin</a>(), candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a33019f6b9cddac75409d536be0c2447b" title="method defined as usual for containers, e.g. ">end</a>() ); <span class="comment">// sort candidates following a very coarse order relation</span></div>
<div class="line">        </div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a60bb17da0a667ff88b9bb011d6b1f65a">fsdict::DictSearch::CandidateSet::const_iterator</a> it = candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a3d6bab588225734bd05b6f4e1bc51782" title="method defined as usual for containers, e.g. ">begin</a>(); it != candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a33019f6b9cddac75409d536be0c2447b" title="method defined as usual for containers, e.g. ">end</a>(); ++it ) {</div>
<div class="line">      std::wcout &lt;&lt;  it-&gt;getWord() &lt;&lt; std::endl;</div>
<div class="line">      std::wcout &lt;&lt;  <span class="stringliteral">&quot;  baseWord=&quot;</span>  &lt;&lt; it-&gt;getBaseWord() &lt;&lt; std::endl;</div>
<div class="line">      std::wcout &lt;&lt;  <span class="stringliteral">&quot;  intruction=&quot;</span>  &lt;&lt; it-&gt;getInstruction() &lt;&lt; std::endl;</div>
<div class="line">      std::wcout &lt;&lt;  <span class="stringliteral">&quot;  levDistance=&quot;</span>  &lt;&lt; it-&gt;getLevDistance() &lt;&lt; std::endl;</div>
<div class="line">      std::wcout &lt;&lt;  <span class="stringliteral">&quot;  dict=&quot;</span>  &lt;&lt; it-&gt;getDictID_string() &lt;&lt; std::endl;</div>
<div class="line">      std::wcout &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="interpretation"></a>
Investigating single candidates (of type fsdict::DictSearch::Interpretation)</h2>
<p><a class="el" href="classfsdict_1_1DictSearch_1_1Interpretation.html" title="This is a specialisation of fsdict::Interpretation, tailored to store additional information added by...">fsdict::DictSearch::Interpretation</a> and its base class <a class="el" href="classfsdict_1_1Interpretation.html" title="This class is something like a container class to store one interpretation of some string as the spel...">fsdict::Interpretation</a> provide lots of information about the candidate they describe. Here are the most useful ones (they are also used in the example above):</p>
<ul>
<li><a class="el" href="classfsdict_1_1Interpretation.html#a310fad97632e414614fc153aee64d028" title="returns a reference to the plain string ">fsdict::Interpretation::getWord()</a> returns the plain string form of the candidate</li>
<li><a class="el" href="classfsdict_1_1Interpretation.html#a00581d16ce098a72b93d91475d7b1710" title="returns the so-called baseWord from the dictionary, that was changed into a variant with the given In...">fsdict::Interpretation::getBaseWord()</a> If the candidate is part of the hypothetical dictionary, here is the modern word it was derived from</li>
<li><a class="el" href="classfsdict_1_1Interpretation.html#a8c54c042ab1d1ede5ea008ab1072ede3" title="returns the instruction that was used to turn baseWord into word ">fsdict::Interpretation::getInstruction()</a> returns an object of type <a class="el" href="classfsdict_1_1Instruction.html" title="Instruction is a std::vector&lt; PosPattern&gt;, and it&#39;s an instruction in the sense we use the word in conn...">fsdict::Instruction</a>, storing the applied variant patterns</li>
<li><a class="el" href="classfsdict_1_1Interpretation.html#a6c118ca6e033373a13e222d9b48c8203" title="returns the levenshtein distance to the query ">fsdict::Interpretation::getLevDistance()</a> returns the levenshtein distance to the query</li>
<li><a class="el" href="classfsdict_1_1Interpretation.html#ad3f13afa9d5ebde49d2ac931529ca334" title="set up a comparison based on the sum of levenshtein or pattern edits. ">fsdict::Interpretation::operator&lt;()</a> defines a very coarse order relation, so the candidates can be pre-sorted using std::sort. The user can easily overrule this sorting order by passing a custom-made sort operator to std::sort.</li>
</ul>
<h1><a class="anchor" id="example_program"></a>
Example: Program Code</h1>
<p>This program code is part of the software package: fsdict/DictSearch/exec_dictSearch_demo.cxx . 'make dictSearch_demo' builds the executable. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="check__sort_8cxx.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() {</div>
<div class="line"></div>
<div class="line">    std::locale::global( std::locale( <span class="stringliteral">&quot;&quot;</span> ) );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create a DictSearch-object</span></div>
<div class="line">    <a class="code" href="classfsdict_1_1DictSearch.html" title="fsdict::DictSearch is a combined interface for approximate dictionary lookup in the context of histor...">fsdict::DictSearch</a> dictSearch;</div>
<div class="line">    <span class="comment">// set a modern dictionary</span></div>
<div class="line">    dictSearch.getConfigModern().setDict( <span class="stringliteral">&quot;../fsdict/DictSearch/Test/small.modern.fbdic&quot;</span> );</div>
<div class="line">    <span class="comment">// configure approx. search on modern dict. with distance bound 2</span></div>
<div class="line">    dictSearch.getConfigModern().setDLev( 2 );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// set a historical dictionary</span></div>
<div class="line">    dictSearch.getConfigHistoric().setDict( <span class="stringliteral">&quot;../fsdict/DictSearch/Test/small.historical.fbdic&quot;</span> );</div>
<div class="line">    <span class="comment">// configure approx. search on modern dict. to choose default distance bounds according to the word length</span></div>
<div class="line">    dictSearch.getConfigHistoric().setDLevWordlengths();</div>
<div class="line">    <span class="comment">// initialise the hypothetic dict. with a file of patterns</span></div>
<div class="line">    dictSearch.<a class="code" href="classfsdict_1_1DictSearch.html#a10d295ac746d3d9c23f97f90c24aae13" title="initialise the hypothetic dictionary. ">initHypothetic</a>( <span class="stringliteral">&quot;../fsdict/DictSearch/Test/small.patterns.txt&quot;</span> );</div>
<div class="line"></div>
<div class="line">    std::wstring query;</div>
<div class="line">    <a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html" title="CandidateSet is a simple container to collect candidates/interpretations from either a Vaam or a fsdi...">fsdict::DictSearch::CandidateSet</a> candSet;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>( std::getline( std::wcin, query ).good() ) {</div>
<div class="line">        candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a3f518bbf1e256610c61d4cd94cf73d80" title="method defined as usual for containers, e.g. ">clear</a>(); <span class="comment">// empty the CandidateSet</span></div>
<div class="line">        dictSearch.<a class="code" href="classfsdict_1_1DictSearch.html#adf7f634c5c410ac90223248f6f5bec2d">query</a>( query, &amp;candSet ); <span class="comment">// execute lookup</span></div>
<div class="line">        std::sort( candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a3d6bab588225734bd05b6f4e1bc51782" title="method defined as usual for containers, e.g. ">begin</a>(), candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a33019f6b9cddac75409d536be0c2447b" title="method defined as usual for containers, e.g. ">end</a>() ); <span class="comment">// sort candidates following a very coarse order relation</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span>( <a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a60bb17da0a667ff88b9bb011d6b1f65a">fsdict::DictSearch::CandidateSet::const_iterator</a> it = candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a3d6bab588225734bd05b6f4e1bc51782" title="method defined as usual for containers, e.g. ">begin</a>(); it != candSet.<a class="code" href="classfsdict_1_1DictSearch_1_1CandidateSet.html#a33019f6b9cddac75409d536be0c2447b" title="method defined as usual for containers, e.g. ">end</a>(); ++it ) {</div>
<div class="line">            std::wcout &lt;&lt;  it-&gt;getWord() &lt;&lt; std::endl;</div>
<div class="line">            std::wcout &lt;&lt;  <span class="stringliteral">&quot;  baseWord=&quot;</span>  &lt;&lt; it-&gt;getBaseWord() &lt;&lt; std::endl;</div>
<div class="line">            std::wcout &lt;&lt;  <span class="stringliteral">&quot;  intruction=&quot;</span>  &lt;&lt; it-&gt;getInstruction() &lt;&lt; std::endl;</div>
<div class="line">            std::wcout &lt;&lt;  <span class="stringliteral">&quot;  levDistance=&quot;</span>  &lt;&lt; it-&gt;getLevDistance() &lt;&lt; std::endl;</div>
<div class="line">            std::wcout &lt;&lt;  <span class="stringliteral">&quot;  dict=&quot;</span>  &lt;&lt; it-&gt;getDictID_string() &lt;&lt; std::endl;</div>
<div class="line">            std::wcout &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="cascading"></a>
Cascading dictionary queries</h1>
<ul>
<li>Dictionaries with top-ranked "CascadingRank" (lowest numbers) are queries first</li>
<li>Dictionaries with lower ranks (higher numbers) are queried only if the higher-ranked dictionaries yielded no results.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>write this section on DictSearch::Cascading dictionary queries</dd></dl>
<h1><a class="anchor" id="known_issues"></a>
Known Bugs/Issues</h1>
<ul>
<li>On Windows we're working on a bug related to the decoding of utf-8 files. Programs will crash if you use anything but ascii characters. It works fine under linux, and soon it will work fine for Windows, too. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 6 2014 23:14:25 for FSDict by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
